// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'all_strings_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AllStringsState {
  List<FavoritableString> get strings => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<FavoritableString> strings) idle,
    required TResult Function(
            FavoritableString item, List<FavoritableString> strings)
        itemfaved,
    required TResult Function(
            FavoritableString item, List<FavoritableString> strings)
        itemUnfaved,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<FavoritableString> strings)? idle,
    TResult? Function(FavoritableString item, List<FavoritableString> strings)?
        itemfaved,
    TResult? Function(FavoritableString item, List<FavoritableString> strings)?
        itemUnfaved,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<FavoritableString> strings)? idle,
    TResult Function(FavoritableString item, List<FavoritableString> strings)?
        itemfaved,
    TResult Function(FavoritableString item, List<FavoritableString> strings)?
        itemUnfaved,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AllStringsState value) idle,
    required TResult Function(_ItemFaved value) itemfaved,
    required TResult Function(_ItemUnfaved value) itemUnfaved,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AllStringsState value)? idle,
    TResult? Function(_ItemFaved value)? itemfaved,
    TResult? Function(_ItemUnfaved value)? itemUnfaved,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AllStringsState value)? idle,
    TResult Function(_ItemFaved value)? itemfaved,
    TResult Function(_ItemUnfaved value)? itemUnfaved,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AllStringsStateCopyWith<AllStringsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AllStringsStateCopyWith<$Res> {
  factory $AllStringsStateCopyWith(
          AllStringsState value, $Res Function(AllStringsState) then) =
      _$AllStringsStateCopyWithImpl<$Res, AllStringsState>;
  @useResult
  $Res call({List<FavoritableString> strings});
}

/// @nodoc
class _$AllStringsStateCopyWithImpl<$Res, $Val extends AllStringsState>
    implements $AllStringsStateCopyWith<$Res> {
  _$AllStringsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? strings = null,
  }) {
    return _then(_value.copyWith(
      strings: null == strings
          ? _value.strings
          : strings // ignore: cast_nullable_to_non_nullable
              as List<FavoritableString>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AllStringsStateCopyWith<$Res>
    implements $AllStringsStateCopyWith<$Res> {
  factory _$$_AllStringsStateCopyWith(
          _$_AllStringsState value, $Res Function(_$_AllStringsState) then) =
      __$$_AllStringsStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<FavoritableString> strings});
}

/// @nodoc
class __$$_AllStringsStateCopyWithImpl<$Res>
    extends _$AllStringsStateCopyWithImpl<$Res, _$_AllStringsState>
    implements _$$_AllStringsStateCopyWith<$Res> {
  __$$_AllStringsStateCopyWithImpl(
      _$_AllStringsState _value, $Res Function(_$_AllStringsState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? strings = null,
  }) {
    return _then(_$_AllStringsState(
      strings: null == strings
          ? _value._strings
          : strings // ignore: cast_nullable_to_non_nullable
              as List<FavoritableString>,
    ));
  }
}

/// @nodoc

class _$_AllStringsState implements _AllStringsState {
  _$_AllStringsState({final List<FavoritableString> strings = const []})
      : _strings = strings;

  final List<FavoritableString> _strings;
  @override
  @JsonKey()
  List<FavoritableString> get strings {
    if (_strings is EqualUnmodifiableListView) return _strings;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_strings);
  }

  @override
  String toString() {
    return 'AllStringsState.idle(strings: $strings)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AllStringsState &&
            const DeepCollectionEquality().equals(other._strings, _strings));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_strings));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AllStringsStateCopyWith<_$_AllStringsState> get copyWith =>
      __$$_AllStringsStateCopyWithImpl<_$_AllStringsState>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<FavoritableString> strings) idle,
    required TResult Function(
            FavoritableString item, List<FavoritableString> strings)
        itemfaved,
    required TResult Function(
            FavoritableString item, List<FavoritableString> strings)
        itemUnfaved,
  }) {
    return idle(strings);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<FavoritableString> strings)? idle,
    TResult? Function(FavoritableString item, List<FavoritableString> strings)?
        itemfaved,
    TResult? Function(FavoritableString item, List<FavoritableString> strings)?
        itemUnfaved,
  }) {
    return idle?.call(strings);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<FavoritableString> strings)? idle,
    TResult Function(FavoritableString item, List<FavoritableString> strings)?
        itemfaved,
    TResult Function(FavoritableString item, List<FavoritableString> strings)?
        itemUnfaved,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(strings);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AllStringsState value) idle,
    required TResult Function(_ItemFaved value) itemfaved,
    required TResult Function(_ItemUnfaved value) itemUnfaved,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AllStringsState value)? idle,
    TResult? Function(_ItemFaved value)? itemfaved,
    TResult? Function(_ItemUnfaved value)? itemUnfaved,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AllStringsState value)? idle,
    TResult Function(_ItemFaved value)? itemfaved,
    TResult Function(_ItemUnfaved value)? itemUnfaved,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class _AllStringsState implements AllStringsState {
  factory _AllStringsState({final List<FavoritableString> strings}) =
      _$_AllStringsState;

  @override
  List<FavoritableString> get strings;
  @override
  @JsonKey(ignore: true)
  _$$_AllStringsStateCopyWith<_$_AllStringsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ItemFavedCopyWith<$Res>
    implements $AllStringsStateCopyWith<$Res> {
  factory _$$_ItemFavedCopyWith(
          _$_ItemFaved value, $Res Function(_$_ItemFaved) then) =
      __$$_ItemFavedCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({FavoritableString item, List<FavoritableString> strings});
}

/// @nodoc
class __$$_ItemFavedCopyWithImpl<$Res>
    extends _$AllStringsStateCopyWithImpl<$Res, _$_ItemFaved>
    implements _$$_ItemFavedCopyWith<$Res> {
  __$$_ItemFavedCopyWithImpl(
      _$_ItemFaved _value, $Res Function(_$_ItemFaved) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? item = null,
    Object? strings = null,
  }) {
    return _then(_$_ItemFaved(
      item: null == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as FavoritableString,
      strings: null == strings
          ? _value._strings
          : strings // ignore: cast_nullable_to_non_nullable
              as List<FavoritableString>,
    ));
  }
}

/// @nodoc

class _$_ItemFaved implements _ItemFaved {
  _$_ItemFaved(
      {required this.item, final List<FavoritableString> strings = const []})
      : _strings = strings;

  @override
  final FavoritableString item;
  final List<FavoritableString> _strings;
  @override
  @JsonKey()
  List<FavoritableString> get strings {
    if (_strings is EqualUnmodifiableListView) return _strings;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_strings);
  }

  @override
  String toString() {
    return 'AllStringsState.itemfaved(item: $item, strings: $strings)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ItemFaved &&
            (identical(other.item, item) || other.item == item) &&
            const DeepCollectionEquality().equals(other._strings, _strings));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, item, const DeepCollectionEquality().hash(_strings));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ItemFavedCopyWith<_$_ItemFaved> get copyWith =>
      __$$_ItemFavedCopyWithImpl<_$_ItemFaved>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<FavoritableString> strings) idle,
    required TResult Function(
            FavoritableString item, List<FavoritableString> strings)
        itemfaved,
    required TResult Function(
            FavoritableString item, List<FavoritableString> strings)
        itemUnfaved,
  }) {
    return itemfaved(item, strings);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<FavoritableString> strings)? idle,
    TResult? Function(FavoritableString item, List<FavoritableString> strings)?
        itemfaved,
    TResult? Function(FavoritableString item, List<FavoritableString> strings)?
        itemUnfaved,
  }) {
    return itemfaved?.call(item, strings);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<FavoritableString> strings)? idle,
    TResult Function(FavoritableString item, List<FavoritableString> strings)?
        itemfaved,
    TResult Function(FavoritableString item, List<FavoritableString> strings)?
        itemUnfaved,
    required TResult orElse(),
  }) {
    if (itemfaved != null) {
      return itemfaved(item, strings);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AllStringsState value) idle,
    required TResult Function(_ItemFaved value) itemfaved,
    required TResult Function(_ItemUnfaved value) itemUnfaved,
  }) {
    return itemfaved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AllStringsState value)? idle,
    TResult? Function(_ItemFaved value)? itemfaved,
    TResult? Function(_ItemUnfaved value)? itemUnfaved,
  }) {
    return itemfaved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AllStringsState value)? idle,
    TResult Function(_ItemFaved value)? itemfaved,
    TResult Function(_ItemUnfaved value)? itemUnfaved,
    required TResult orElse(),
  }) {
    if (itemfaved != null) {
      return itemfaved(this);
    }
    return orElse();
  }
}

abstract class _ItemFaved implements AllStringsState {
  factory _ItemFaved(
      {required final FavoritableString item,
      final List<FavoritableString> strings}) = _$_ItemFaved;

  FavoritableString get item;
  @override
  List<FavoritableString> get strings;
  @override
  @JsonKey(ignore: true)
  _$$_ItemFavedCopyWith<_$_ItemFaved> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ItemUnfavedCopyWith<$Res>
    implements $AllStringsStateCopyWith<$Res> {
  factory _$$_ItemUnfavedCopyWith(
          _$_ItemUnfaved value, $Res Function(_$_ItemUnfaved) then) =
      __$$_ItemUnfavedCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({FavoritableString item, List<FavoritableString> strings});
}

/// @nodoc
class __$$_ItemUnfavedCopyWithImpl<$Res>
    extends _$AllStringsStateCopyWithImpl<$Res, _$_ItemUnfaved>
    implements _$$_ItemUnfavedCopyWith<$Res> {
  __$$_ItemUnfavedCopyWithImpl(
      _$_ItemUnfaved _value, $Res Function(_$_ItemUnfaved) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? item = null,
    Object? strings = null,
  }) {
    return _then(_$_ItemUnfaved(
      item: null == item
          ? _value.item
          : item // ignore: cast_nullable_to_non_nullable
              as FavoritableString,
      strings: null == strings
          ? _value._strings
          : strings // ignore: cast_nullable_to_non_nullable
              as List<FavoritableString>,
    ));
  }
}

/// @nodoc

class _$_ItemUnfaved implements _ItemUnfaved {
  _$_ItemUnfaved(
      {required this.item, final List<FavoritableString> strings = const []})
      : _strings = strings;

  @override
  final FavoritableString item;
  final List<FavoritableString> _strings;
  @override
  @JsonKey()
  List<FavoritableString> get strings {
    if (_strings is EqualUnmodifiableListView) return _strings;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_strings);
  }

  @override
  String toString() {
    return 'AllStringsState.itemUnfaved(item: $item, strings: $strings)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ItemUnfaved &&
            (identical(other.item, item) || other.item == item) &&
            const DeepCollectionEquality().equals(other._strings, _strings));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, item, const DeepCollectionEquality().hash(_strings));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ItemUnfavedCopyWith<_$_ItemUnfaved> get copyWith =>
      __$$_ItemUnfavedCopyWithImpl<_$_ItemUnfaved>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<FavoritableString> strings) idle,
    required TResult Function(
            FavoritableString item, List<FavoritableString> strings)
        itemfaved,
    required TResult Function(
            FavoritableString item, List<FavoritableString> strings)
        itemUnfaved,
  }) {
    return itemUnfaved(item, strings);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<FavoritableString> strings)? idle,
    TResult? Function(FavoritableString item, List<FavoritableString> strings)?
        itemfaved,
    TResult? Function(FavoritableString item, List<FavoritableString> strings)?
        itemUnfaved,
  }) {
    return itemUnfaved?.call(item, strings);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<FavoritableString> strings)? idle,
    TResult Function(FavoritableString item, List<FavoritableString> strings)?
        itemfaved,
    TResult Function(FavoritableString item, List<FavoritableString> strings)?
        itemUnfaved,
    required TResult orElse(),
  }) {
    if (itemUnfaved != null) {
      return itemUnfaved(item, strings);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AllStringsState value) idle,
    required TResult Function(_ItemFaved value) itemfaved,
    required TResult Function(_ItemUnfaved value) itemUnfaved,
  }) {
    return itemUnfaved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_AllStringsState value)? idle,
    TResult? Function(_ItemFaved value)? itemfaved,
    TResult? Function(_ItemUnfaved value)? itemUnfaved,
  }) {
    return itemUnfaved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AllStringsState value)? idle,
    TResult Function(_ItemFaved value)? itemfaved,
    TResult Function(_ItemUnfaved value)? itemUnfaved,
    required TResult orElse(),
  }) {
    if (itemUnfaved != null) {
      return itemUnfaved(this);
    }
    return orElse();
  }
}

abstract class _ItemUnfaved implements AllStringsState {
  factory _ItemUnfaved(
      {required final FavoritableString item,
      final List<FavoritableString> strings}) = _$_ItemUnfaved;

  FavoritableString get item;
  @override
  List<FavoritableString> get strings;
  @override
  @JsonKey(ignore: true)
  _$$_ItemUnfavedCopyWith<_$_ItemUnfaved> get copyWith =>
      throw _privateConstructorUsedError;
}
